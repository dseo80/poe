
; Read all of the following preferences , theyre in the settings.ini in c:\users\%profile%\documents\autohotkey

; GUI's in use : 1, 2, 3, 4, 5

#NoEnv  ; Recommended for performance and compatibility with future AutoHotkey releases.
#SingleInstance force

FileEncoding , UTF-8
SendMode Input
SetTitleMatchMode, 3

If (A_AhkVersion <= "1.1.15")
{
	msgbox, You need AutoHotkey v1.1.15 or later to run this script. `n`nPlease go to http://ahkscript.org/download and download a recent version.
	exit
}

If !A_IsAdmin {
	Run *RunAs "%A_ScriptFullPath%"
	ExitApp
}

IfNotExist, %A_MyDocuments%\AutoHotkey\Lib
{
	FileCreateDir, %A_MyDocuments%\AutoHotKey\Lib
}
SetWorkingDir %A_MyDocuments%\AutoHotKey

IfNotExist, cports.exe
{
UrlDownloadToFile, http://lutbot.com/ahk/cports.exe, cports.exe
	if ErrorLevel
			MsgBox, Error %ErrorLevel% at ED02 : There was a problem downloading cports.exe
UrlDownloadToFile, http://lutbot.com/ahk/cports.chm, cports.chm
	if ErrorLevel
			MsgBox, Error %ErrorLevel% at ED03 : There was a problem downloading cports.chm 
UrlDownloadToFile, http://lutbot.com/ahk/readme.txt, readme.txt
	if ErrorLevel
			MsgBox, Error %ErrorLevel% at ED04 : There was a problem downloading readme.txt
}

IfNotExist, settings.ini
{
	defaultIni := "[variables]`n"
	defaultIni .= "CharacterName=BTOneMonthLut`n"
	defaultIni .= "AccountName=Lutcikaur`n"
	defaultIni .= "League=standard`n"
	defaultIni .= "PoeSteam=0`n"
	defaultIni .= "UpdateTimer=1000`n"
	defaultIni .= "XOffset=0`n"
	defaultIni .= "YOffset=0`n"
	defaultIni .= "MonitorWhispers=0`n"
	defaultIni .= "MonitorWhispersDelay=10000`n"
	defaultIni .= "LogFileLocation=ERROR PLEASE SELECT LOG FILE`n"
	defaultIni .= "OverlayToggle=0`n"
	defaultIni .= "SoundSelector=*-1`n"
	defaultIni .= "[whisperMessages]`n"
	defaultIni .= "wm1=One moment, I'm in a map.`n"
	defaultIni .= "wm2=Type a sentence here`n"
	defaultIni .= "wm3=Type a sentence here`n"
	defaultIni .= "wm4=Type a sentence here`n"
	defaultIni .= "wm5=Type a sentence here`n"
	defaultIni .= "[partyMessages]`n"
	defaultIni .= "pm1=Watch for corrupting blood!`n"
	defaultIni .= "pm2=Type a sentence here`n"
	defaultIni .= "pm3=Dangerous exile!`n"
	defaultIni .= "pm4=Minion Instability / Iceblood!`n"
	defaultIni .= "pm5=Type a sentence here`n"
	defaultIni .= "[hotkeys]`n"
	defaultIni .= "logout=```n"
	defaultIni .= "superLogout=F12`n"
	defaultIni .= "oos=F2`n"
	defaultIni .= "remaining=F3`n"
	defaultIni .= "itemLevel=F4`n"
	defaultIni .= "hideout=F5`n"
	defaultIni .= "invite=F6`n"
	defaultIni .= "toggleOverlay=F9`n"
	defaultIni .= "options=F10`n"
	defaultIni .= "wm1=^1`n"
	defaultIni .= "wm2=^2`n"
	defaultIni .= "wm3=^3`n"
	defaultIni .= "wm4=^4`n"
	defaultIni .= "wm5=^5`n"
	defaultIni .= "pm1=!1`n"
	defaultIni .= "pm2=!2`n"
	defaultIni .= "pm3=!3`n"
	defaultIni .= "pm4=!4`n"
	defaultIni .= "pm5=!5"

	FileAppend, %defaultIni%, settings.ini, UTF-16
}


;Get league listing
UrlDownloadToFile, http://api.exiletools.com/ladder?activeleagues=1, leagues.json
	if ErrorLevel
			MsgBox, Error %ErrorLevel% at ED09 : Error downloading list of active leagues

FileRead, leagues, leagues.json
JSON_obj_leagues := json_toobj(leagues)
leagueString := JSON_obj_leagues[0]
while JSON_obj_leagues[a_index] != "" 
{
	leagueString .= "|" . JSON_obj_leagues[a_index]
}

; Holy fuck inefficient.. MAP LISTINGS!!!
map1 :=  "crypt"
map2 :=  "desert"
map3 :=  "dunes"
map4 :=  "dungeon"
map5 :=  "grotto"
map6 :=  "pit"
map7 :=  "tropical_island"
map8 :=  "aqueduct"
map9 :=  "arcade"
map10 :=  "cemetery"
map11 :=  "channel"
map12 :=  "mountain_ledge"
map13 :=  "sewer"
map14 :=  "thicket"
map15 :=  "wharf"
map16 :=  "ghetto"
map17 :=  "mud_geyser"
map18 :=  "museum"
map19 :=  "quarry"
map20 :=  "reef"
map21 :=  "spider_lair"
map22 :=  "vaal_pyramid"
map23 :=  "arena"
map24 :=  "overgrown_shrine"
map25 :=  "promenade"
map26 :=  "shore"
map27 :=  "spider_forest"
map28 :=  "tunnel"
map29 :=  "bog"
map30 :=  "coves"
map31 :=  "graveyard"
map32 :=  "pier"
map33 :=  "underground_sea"
map34 :=  "villa"
map35 :=  "arachnid_nest"
map36 :=  "catacomb"
map37 :=  "colonnade"
map38 :=  "dry_woods"
map39 :=  "strand"
map40 :=  "temple"
map41 :=  "jungle_valley"
map42 :=  "labyrinth"
map43 :=  "mine"
map44 :=  "torture_chamber"
map45 :=  "waste_pool"
map46 :=  "canyon"
map47 :=  "cells"
map48 :=  "dark_forest"
map49 :=  "dry_peninsula"
map50 :=  "orchard"
map51 :=  "arid_lake"
map52 :=  "gorge"
map53 :=  "residence"
map54 :=  "underground_river"
map55 :=  "abyss"
map56 :=  "bazaar"
map57 :=  "necropolis"
map58 :=  "plateau"
map59 :=  "academy"
map60 :=  "crematorium"
map61 :=  "precinct"
map62 :=  "springs"
map63 :=  "arsenal"
map64 :=  "overgrown_ruin"
map65 :=  "shipyard"
map66 :=  "village_ruin"
map67 :=  "courtyard"
map68 :=  "excavation"
map69 :=  "wasteland"
map70 :=  "waterways"
map71 :=  "maze"
map72 :=  "palace"
map73 :=  "shrine"
map74 :=  "vaal_temple"
map75 :=  "colosseum"
map76 :=  "core"
map77 :=  "volcano"

;Get TEMPEST listing
UrlDownloadToFile,http://poetempest.com/api/v0/current_tempests, tempests.json
	if ErrorLevel
			MsgBox, Error ED10 : Error downloading list of active tempests
FileRead, tmo, tempests.json
JSON_obj_tempests := json_toobj(tmo)

Loop, 76
{
	tempest%A_Index% := JSON_obj_tempests[map%A_Index%].name
}

;end TEMPEST listing

readFromFile()

current := 0
phase := 0
lastWhisperTimeRecieved := 0

;timers
updateTrackingTimer := 5000 ; 5 seconds
baseUpdateTrackingTimer := 300000 ; 5 minutes
oosTimer := 0
baseOosTimer := 1000
overlayTimer := 0
baseOverlayTimer := sleepTimer
updateTrackingTimerActive := true
oosTimerActive := false
overlayTimerActive := true
refreshTempestTimerActive := true
refreshTempestTimer := 450000
lastUpdated := 1

;Ranking Overlay
Gui, 1:+ToolWindow
Gui, 1:Font, s8
Gui, 1:Add, Text, x3 y2 vguiOos, OOS: Ready
Gui, 1:Add, Text, x3 y17, Settings:F10
Gui, 1:Font, s14
Gui, 1:Add, Text, x67 y4 w120 vguiRank, Rank: N/A
Gui, 1:Add, Text, x175 y4 w55 vguiMovedRanks, N/A
Gui, 1:Font, s7
Gui, 1:Add, Text, x3 y32, Exp Above :
Gui, 1:Add, Text, x3 y47, Exp Below :
Gui, 1:Add, Text, x66 y32 w66 vguiAbove1, N/A
Gui, 1:Add, Text, x135 y32 w66 vguiAbove2, N/A
Gui, 1:Add, Text, x66 y47 w66 vguiBelow1, N/A
Gui, 1:Add, Text, x135 y47 w66 vguiBelow2, N/A
Gui, 1:Font, s14

Gui, 1:Show, x0 y0 w225 h37, poeGUI
Gui, 1:-Caption +AlwaysOnTop +Disabled +E0x20 +LastFound
Winset,TransColor, 0xFFFFFF

;Tempest Overlay
Gui, 5:+ToolWindow
Gui, 5:Font, s8
Gui, 5:Margin, 0, 0
Gui, 5:Add, ListView, -LV0x10 -ReadOnly R39 -WantF2 w600, Map|Tempest|Map|Tempest

Gui, 5:Default
Gui, 5:ListView, LV1
drawTempests()
LV_ModifyCol()
LV_ModifyCol(1,98)
LV_ModifyCol(2,200)
LV_ModifyCol(3,98)
LV_ModifyCol(4,200)
Gui, 5:Show, x0 y0 w590 h670, tempestGUI
Gui, 5:-Caption +AlwaysOnTop +Disabled +E0x20 +LastFound
Winset,TransColor, 0xFFFFFE


; some fucking initializers. Put these together later.
toggle--
toggleOverlay()

;start the main loop. Gotta be last
loopTimers()

toggleOverlay(){
toggleOverlayCommand:
	global toggle
	toggle++
	if toggle > 2
		toggle := -1
	if toggle = -1
	{
		Gui, 1:Hide
		Gui, 5:Hide
	}
	if toggle = 0
	{
		Gui, 5:Hide
		Gui, 1:Show, h60 NA
	}
	if toggle = 1
	{
		Gui, 5:Hide
		Gui, 1:Show, h31 NA
	} 
	if toggle = 2
	{
		Gui, 5:Show, NA
		Gui, 1:Hide
	}
	return
}

checkOverlay(){
	global overlayTimer, baseOverlayTimer, toggle, xOffset, yOffset
	if toggle != -1
	{
			IfWinActive Path of Exile
			{
				WinGetActiveStats,name,width,height,x,y
				width += x
				width += xOffset
				hh := y
				hh += yOffset
				if toggle = 2 
				{
					width /= 2
					width -= 295
					height /= 2
					height -= 325
					Gui, 5:Show,  y%height% x%width% NA
				} 
				if ( toggle = 1 ) || ( toggle = 0 )
				{
					width -= 231
					Gui, 1:Show,  y%hh% x%width% NA
				}
			} else {
				Gui, 1:Hide
				Gui, 5:Hide
			}
	}
	overlayTimer := baseOverlayTimer
	return
}





loopTimers(){
	global
	Loop {
		if ( overlayTimerActive = true ) 
			overlayTimer -= sleepTime    
		if ( oosTimerActive = true )
			oosTimer -= sleepTime
		if ( updateTrackingTimerActive = true )
			updateTrackingTimer -= sleepTime
		if ( monitorWhispers )
			monitorWhispersTimer -= sleepTime
		if ( refreshTempestTimerActive )
			refreshTempestTimer -= sleepTime

		if ( overlayTimer <= 0 ) && ( overlayTimerActive = true )
		{
			checkOverlay()
		}
				
		if ( oosTimer <= 0 ) && ( oosTimerActive = true )
		{
			updateOos()
		}
				
		if ( updateTrackingTimer <= 0 ) && ( updateTrackingTimerActive = true )
		{
			IfWinExist, Path of Exile
				updateTracking()
			else
				updateTrackingTimer := 60000
		}

		if ( refreshTempestTimer <= 0 ) && ( refreshTempestTimerActive = true ) 
		{
			IfWinExist, Path of Exile
				refreshTempests()
			else
				refreshTempestTimer := 60000
		}

		if ( monitorWhispersTimer <= 0 ) && ( monitorWhispers )
		{
			IfWinExist, Path of Exile
				checkForWhispers()
		}
		Sleep sleepTime  
	}
	return
}

drawTempests(){
	global
	Loop, 39
	{
		i := A_Index + 39
		m := map%i%
		t := tempest%i%
		LV_Add("", map%A_Index%, tempest%A_Index%,m,t)
	}
return
}


refreshTempests(){
	global

	UrlDownloadToFile,http://poetempest.com/api/v0/current_tempests, tempests.json
	if ErrorLevel
			MsgBox, Error %ErrorLevel% at ED10 : Error downloading list of active tempests

	FileRead, tmo, tempests.json
	JSON_obj_tempests := json_toobj(tmo)

	Gui, 5:Default
	Gui, 5:ListView, LV1
	Loop, 39
	{
		i := A_Index + 39
		LV_Modify(A_Index,"Col2", JSON_obj_tempests[map%A_Index%].name)
		LV_Modify(A_Index,"Col4", JSON_obj_tempests[map%i%].name)
	}
	
	refreshTempestTimer := 900000
}

updateTracking(){
	global charName, accName, league, updateTrackingTimer, baseUpdateTrackingTimer, lastUpdated

	url := "http://poe.pwx.me/api/ladder?league=" . league . "&char=" . charName . ""

	UrlDownloadToFile, %url%, ladder.json
		if ErrorLevel
			GuiControl,1:, rank, "Rank: Error %ErrorLevel% at ED01"

	FileRead, ladderString, ladder.json
	JSON_obj := json_toobj(ladderString)

	combined := accName . "." . charName
	updated := JSON_obj[combined].updated
	if ( updated = lastUpdated )
	{
		updateTrackingTimer := 60000 ; Wait one minute to check again
		return
	}
	lastUpdated := updated
	rank := JSON_obj[combined].rank
	if ( !rank ) {
		rank := "Min Lv:"
		url := "http://poe.pwx.me/api/ladder?league=" . league . "&status=1"
		UrlDownloadToFile, %url%, league.json
			if ErrorLevel
				GuiControl,1:, rank, "Rank: Error %ErrorLevel% at ED05"
		FileRead, leagueString, league.json
		leagueObj := json_toobj(leagueString)
		movedRanks := leagueObj[league].toGetOnLadder.level
		above1 = N/A
		above2 = N/A
		below1 = N/A
		below2 = N/A
	} else {
		movedRanks := JSON_obj[combined].movedRanks
		above1 := JSON_obj[combined].xp_to_rank_above[rank-1]
		above1 := RegExReplace(above1, "(\d)(?=(?:\d{3})+(?:\.|$))", "$1,")
		above2 := JSON_obj[combined].xp_to_rank_above[rank-2]
		above2 := RegExReplace(above2, "(\d)(?=(?:\d{3})+(?:\.|$))", "$1,")
		below1 := JSON_obj[combined].xp_to_rank_below[rank+1]
		below1 := RegExReplace(below1, "(\d)(?=(?:\d{3})+(?:\.|$))", "$1,")
		below2 := JSON_obj[combined].xp_to_rank_below[rank+2]
		below2 := RegExReplace(below2, "(\d)(?=(?:\d{3})+(?:\.|$))", "$1,")
		rank := "Rank: " . rank
		if ( movedRanks < 0 ) {
			Gui, 1:Font, cRed
			GuiControl, 1:Font, guiMovedRanks
		}
		if ( movedRanks > 0 ) {
			Gui, 1:Font, cGreen
			GuiControl, 1:Font, guiMovedRanks
		}
	}

	GuiControl,1:,guiAbove1, %above1%
	GuiControl,1:,guiAbove2, %above2%
	GuiControl,1:,guiBelow1, %below1%
	GuiControl,1:,guiBelow2, %below2%

	GuiControl,1:, guiRank, %rank%
	GuiControl,1:, guiMovedRanks, %movedRanks%

	updateTrackingTimer := baseUpdateTrackingTimer ; Wait the base time

	return
}

	; variables
	IniRead, charName, settings.ini, variables, CharacterName
	IniRead, accName, settings.ini, variables, AccountName
	IniRead, league, settings.ini, variables, League
	IniRead, steam, settings.ini, variables, PoeSteam
	IniRead, sleepTime, settings.ini, variables, UpdateTimer
	IniRead, xOffset, settings.ini, variables, XOffset
	IniRead, yOffset, settings.ini, variables, YOffset
	IniRead, monitorWhispers, settings.ini, variables, MonitorWhispers
	IniRead, monitorWhispersDelay, settings.ini, variables, MonitorWhispersDelay
	IniRead, logFileLocation, settings.ini, variables, LogFileLocation
	IniRead, toggle, settings.ini, variables, OverlayToggle
	IniRead, soundSelector, settings.ini, variables, SoundSelector
	; whisper messages
	IniRead, wm1, settings.ini, whisperMessages, wm1
	IniRead, wm2, settings.ini, whisperMessages, wm2
	IniRead, wm3, settings.ini, whisperMessages, wm3
	IniRead, wm4, settings.ini, whisperMessages, wm4
	IniRead, wm5, settings.ini, whisperMessages, wm5
	;party messages
	IniRead, pm1, settings.ini, partyMessages, pm1
	IniRead, pm2, settings.ini, partyMessages, pm2
	IniRead, pm3, settings.ini, partyMessages, pm3
	IniRead, pm4, settings.ini, partyMessages, pm4
	IniRead, pm5, settings.ini, partyMessages, pm5
	;hotkeys
	IniRead, hotkeyLogout, settings.ini, hotkeys, logout, %A_Space%
	IniRead, hotkeySuperLogout, settings.ini, hotkeys, superLogout, %A_Space%
	IniRead, hotkeyOos, settings.ini, hotkeys, oos, %A_Space%
	IniRead, hotkeyRemaining, settings.ini, hotkeys, remaining, %A_Space%
	IniRead, hotkeyItemLevel, settings.ini, hotkeys, itemLevel, %A_Space%
	IniRead, hotkeyHideout, settings.ini, hotkeys, hideout, %A_Space%
	IniRead, hotkeyInvite, settings.ini, hotkeys, invite, %A_Space%
	IniRead, hotkeyToggleOverlay, settings.ini, hotkeys, toggleOverlay, %A_Space%
	IniRead, hotkeyOptions, settings.ini, hotkeys, options, %A_Space%
	IniRead, hotkeywm1, settings.ini, hotkeys, wm1, %A_Space%
	IniRead, hotkeywm2, settings.ini, hotkeys, wm2, %A_Space%
	IniRead, hotkeywm3, settings.ini, hotkeys, wm3, %A_Space%
	IniRead, hotkeywm4, settings.ini, hotkeys, wm4, %A_Space%
	IniRead, hotkeywm5, settings.ini, hotkeys, wm5, %A_Space%
	IniRead, hotkeypm1, settings.ini, hotkeys, pm1, %A_Space%
	IniRead, hotkeypm2, settings.ini, hotkeys, pm2, %A_Space%
	IniRead, hotkeypm3, settings.ini, hotkeys, pm3, %A_Space%
	IniRead, hotkeypm4, settings.ini, hotkeys, pm4, %A_Space%
	IniRead, hotkeypm5, settings.ini, hotkeys, pm5, %A_Space%


	string :=""
	if ( steam ) {
		string:= "cports.exe /close * * * * PathOfExileSteam.exe"
	} else {
		string:= "cports.exe /close * * * * PathOfExile.exe"
	}

	updateTrackingTimer := 5000
	monitorWhispersTimer := monitorWhispersDelay
}

; ; ERROR LIST
; min lv = null : you typed in the league name wrong.
; ED01 : Error downloading rank from http://poe.pwx.me/ , their server might be unavailible.
; ED02 -> ED04 : Error downloading currports from my website. http://www.nirsoft.net/utils/cports.html holds the original file.
; ED05 : Error downloading ladder stats from http://poe.pwx.me/ , their server might be unavailible.
; ED06 : Error checking for new version.
; ED07 : Error downloading newest version of ahk script.
; ED08 : Error downloading newest changelog.
; ED09 : Error downloading list of active leagues
; ED10 : Error downloading list of active tempests
; ED11 : Error downloading tempest : map%A_Index%
; ED12 : Error downloading all tempests

; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; JSON -> AHK Obj parser by VxE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Copyright © 2013 VxE. All rights reserved.

; Uses a two-pass iterative approach to deserialize a json string
json_toobj( str ) {

		quot := """" ; firmcoded specifically for readability. Hardcode for (minor) performance gain
		ws := "`t`n`r " Chr(160) ; whitespace plus NBSP. This gets trimmed from the markup
		obj := {} ; dummy object
		objs := [] ; stack
		keys := [] ; stack
		isarrays := [] ; stack
		literals := [] ; queue
		y := nest := 0

; First pass swaps out literal strings so we can parse the markup easily
		StringGetPos, z, str, %quot% ; initial seek
		while !ErrorLevel
		{
				; Look for the non-literal quote that ends this string. Encode literal backslashes as '\u005C' because the
				; '\u..' entities are decoded last and that prevents literal backslashes from borking normal characters
				StringGetPos, x, str, %quot%,, % z + 1
				while !ErrorLevel
				{
						StringMid, key, str, z + 2, x - z - 1
						StringReplace, key, key, \\, \u005C, A
						If SubStr( key, 0 ) != "\"
								Break
						StringGetPos, x, str, %quot%,, % x + 1
				}
		;       StringReplace, str, str, %quot%%t%%quot%, %quot% ; this might corrupt the string
				str := ( z ? SubStr( str, 1, z ) : "" ) quot SubStr( str, x + 2 ) ; this won't

		; Decode entities
				StringReplace, key, key, \%quot%, %quot%, A
				StringReplace, key, key, \b, % Chr(08), A
				StringReplace, key, key, \t, % A_Tab, A
				StringReplace, key, key, \n, `n, A
				StringReplace, key, key, \f, % Chr(12), A
				StringReplace, key, key, \r, `r, A
				StringReplace, key, key, \/, /, A
				while y := InStr( key, "\u", 0, y + 1 )
						if ( A_IsUnicode || Abs( "0x" SubStr( key, y + 2, 4 ) ) < 0x100 )
								key := ( y = 1 ? "" : SubStr( key, 1, y - 1 ) ) Chr( "0x" SubStr( key, y + 2, 4 ) ) SubStr( key, y + 6 )

				literals.insert(key)

				StringGetPos, z, str, %quot%,, % z + 1 ; seek
		}

; Second pass parses the markup and builds the object iteratively, swapping placeholders as they are encountered
		key := isarray := 1

		; The outer loop splits the blob into paths at markers where nest level decreases
		Loop Parse, str, % "]}"
		{
				StringReplace, str, A_LoopField, [, [], A ; mark any array open-brackets

				; This inner loop splits the path into segments at markers that signal nest level increases
				Loop Parse, str, % "[{"
				{
						; The first segment might contain members that belong to the previous object
						; Otherwise, push the previous object and key to their stacks and start a new object
						if ( A_Index != 1 )
						{
								objs.insert( obj )
								isarrays.insert( isarray )
								keys.insert( key )
								obj := {}
								isarray := key := Asc( A_LoopField ) = 93
						}

						; arrrrays are made by pirates and they have index keys
						if ( isarray )
						{
								Loop Parse, A_LoopField, `,, % ws "]"
										if ( A_LoopField != "" )
												obj[key++] := A_LoopField = quot ? literals.remove(1) : A_LoopField
						}
						; otherwise, parse the segment as key/value pairs
						else
						{
								Loop Parse, A_LoopField, `,
										Loop Parse, A_LoopField, :, % ws
												if ( A_Index = 1 )
														key := A_LoopField = quot ? literals.remove(1) : A_LoopField
												else if ( A_Index = 2 && A_LoopField != "" )
														obj[key] := A_LoopField = quot ? literals.remove(1) : A_LoopField
						}
						nest += A_Index > 1
				} ; Loop Parse, str, % "[{"

				If !--nest
						Break

				; Insert the newly closed object into the one on top of the stack, then pop the stack
				pbj := obj
				obj := objs.remove()
				obj[key := keys.remove()] := pbj
				If ( isarray := isarrays.remove() )
						key++

		} ; Loop Parse, str, % "]}"

		Return obj
} ; json_toobj( str )
